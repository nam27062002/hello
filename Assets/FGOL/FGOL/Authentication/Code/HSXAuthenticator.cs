using FGOL.Server;
using FGOL.ThirdParty.MiniJSON;
using FGOL.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace FGOL.Authentication
{
    public class HSXAuthenticator /*: AutoGeneratedSingleton<HSXAuthenticator>*/
    {
        public enum AuthState
        {
            NewUser,
            NewSocialLogin,
            Authenticated,
            Unknown,
            Error
        }

        public class AuthResult
        {
            public string fgolID;
            public string cloudSaveLocation;
            public string cloudSaveBucket;
            public string sessionToken;
            public int sessionExpiry;
            public Dictionary<string, object> cloudCredentials;
            public int cloudCredentialsExpiry;
            public int socialExpiry;
            public AuthState authState;
            public bool upgradeAvailable;
            public bool cloudSaveAvailable;
        }

        public const string server = "FGOLAuth";

        private Command m_pingCommand = null;
        private Command m_authCommand = null;
        private Command m_logoutCommand = null;
        private Command m_requestPassCommand = null;
        private Command m_recordTokenCommand = null;
        private Command m_updateSaveVersion = null;
        private Command m_getServerTime = null;

        private DeviceToken m_deviceToken = null;

        private User m_user = null;
        public User User 
        { 
            get { return m_user; }
            set { m_user = value; }
        }

        public Action OnLoggedIn = null;

        public HSXAuthenticator()
        {
            m_pingCommand           = new Command("Ping",               "/Ping",            server, Command.Type.Normal, Request.Method.GET, 5, 5);
            m_authCommand           = new Command("Auth",               "/Auth",            server, Command.Type.Normal);
            m_logoutCommand         = new Command("Logout",             "/Logout",          server, Command.Type.Authenticated);
            m_requestPassCommand    = new Command("RequestPassword",    "/RequestPassword", server, Command.Type.Normal);
            m_recordTokenCommand    = new Command("RecordPushToken",    "/RecordPushToken", server, Command.Type.Authenticated);
            m_updateSaveVersion     = new Command("UpdateUploadedVersion", "/UpdateUploadedVersion", server, Command.Type.Authenticated);
            m_getServerTime         = new Command("GetServerTime",      "/GetServerTime",   server, Command.Type.Normal, Request.Method.GET);

            m_deviceToken = new DeviceToken();
        }

        public DeviceToken Token
        {
            get { return m_deviceToken; }
        }

		public void SetBaseUrl(string url)
		{
            Command.BaseUrls[server] = url;
		}

        public bool CheckIfAuthCommand(Command command)
        {
            return m_authCommand.Name == command.Name;
        }

        public void CheckConnection(Action<Error> callback)
        {
            if (Application.internetReachability != NetworkReachability.NotReachable)
            {
                Commander.Instance.RunCommand(m_pingCommand, null, delegate (Error error, Dictionary<string, object> result)
                {
                    if (error == null)
                    {
                        if (result != null)
                        {
                            if (result.ContainsKey("Pong"))
                            {
                                if (result.ContainsKey("Region"))
                                {
                                    Debug.Log("Authenticator (CheckConnection) :: Connecting to region - " + result["Region"]);
                                }
                            }
                            else
                            {
                                error = new InvalidServerResponseError("Response not as expected");
                            }
                        }
                        else
                        {
                            error = new InvalidServerResponseError("Response not as expected");
                        }
                    }

                    if (error != null)
                    {
                        Debug.LogWarning(string.Format("Authenticator (CheckConnection) :: Error - {0}", error));
                    }

                    callback(error);
                });
            }
            else
            {
                Debug.Log("Authenticator (CheckConnection) :: InternetReachability NotReachable");
                callback(new ClientConnectionError("InternetReachability NotReachable", ErrorCodes.ClientConnectionError));
            }
        }

        public void GetServerTime(Action<Error, string, int> onGetServerTime)
        {
            Commander.Instance.RunCommand(m_getServerTime, null, delegate (Error error, Dictionary<string, object> result)
            {
                string dateTimeNow = null;
                int unixTimestamp = -1;

                if (error == null)
                {
                    if (result != null && result.ContainsKey("dateTime") && result.ContainsKey("unixTimestamp"))
                    {
                        dateTimeNow = result["dateTime"] as string;

                        try
                        {
                            unixTimestamp = Convert.ToInt32(result["unixTimestamp"]);
                        }
                        catch (Exception) { }
                    }
                    else
                    { 
                        error = new InvalidServerResponseError("Response not as expected");
                    }
                }

                onGetServerTime(error, dateTimeNow, unixTimestamp);
            });
        }

        public void Authenticate(string fgolID, User.LoginCredentials credentials, User.LoginType network, Action<Error, AuthResult> callback)
        {
            Dictionary<string, string> parameters = new Dictionary<string,string>();

            parameters["authMethod"] = network.ToString();
            parameters["deviceToken"] = m_deviceToken.ToString();

            if(!string.IsNullOrEmpty(fgolID))
            {
                parameters["fgolID"] = fgolID;
            }

            parameters["credentials"] = Json.Serialize(credentials.ToDictionary());

            Commander.Instance.RunCommand(m_authCommand, parameters, delegate(Error commandError, Dictionary<string, object> response)
            {
                if(commandError == null)
                {
                    string[] requiredParams = new string[] { "cloudCredentials", "cloudCredentialsExpiry", "fgolID", "savePath", "bucket", "sessionToken", "sessionExpiry", "socialExpiry", "authState", "cloudSaveAvailable" };

                    if(Commander.IsValidResponse(response, requiredParams))
                    {
                        AuthResult result = new AuthResult();
                        result.fgolID = response["fgolID"] as string;
                        result.cloudSaveLocation = response["savePath"] as string;
                        result.cloudSaveBucket = response["bucket"] as string;
                        result.sessionToken = response["sessionToken"] as string;
                        result.sessionExpiry = Convert.ToInt32(response["sessionExpiry"]);
                        result.cloudCredentials = response["cloudCredentials"] as Dictionary<string, object>;
                        result.cloudCredentialsExpiry = Convert.ToInt32(response["cloudCredentialsExpiry"]);
                        result.socialExpiry = Convert.ToInt32(response["socialExpiry"]);
                        result.authState = (AuthState)Enum.Parse(typeof(AuthState), response["authState"] as string);
                        result.upgradeAvailable = response.ContainsKey("upgradeAvailable") && Convert.ToBoolean(response["upgradeAvailable"]);
                        result.cloudSaveAvailable = Convert.ToBoolean(response["cloudSaveAvailable"]);

                        callback(null, result);

                        if(OnLoggedIn != null)
                        {
                            OnLoggedIn();
                        }
                    }
                    else
                    {
                        callback(new InvalidServerResponseError("Missing response params: " + string.Join(",", requiredParams)), null);
                    }
                }
                else
                {
                    callback(commandError, null);
                }
            });
        }

        public void Logout(Action<Error> callback)
        {
            if(m_user != null)
            {
                Commander.Instance.RunCommand(m_logoutCommand, new Dictionary<string, string>(), delegate(Error error, Dictionary<string, object> result)
                {
                    if(error == null)
                    {
                        if(!result.ContainsKey("loggedOut"))
                        {
                            error = new UnknownError("Log out unsuccesful");
                        }
                    }

                    callback(error);
                });
            }
            else
            {
                callback(null);
            }
        }

        public void RequestPassword(string email, Action<Error> callback)
        {
            Dictionary<string, string> parameters = new Dictionary<string, string>
            {
                { "email", email }
            };

            Commander.Instance.RunCommand(m_requestPassCommand, parameters, delegate(Error error, Dictionary<string, object> result)
            {
                callback(error);
            });
        }

        public void UpdateSaveVersion(bool preliminary, Action<Error, int> onUpdate)
        {
            Dictionary<string, string> parameters = new Dictionary<string, string>
            {
                { "fgolID", User.ID }
            };

            if(preliminary)
            {
                parameters["prelimUpdate"] = preliminary.ToString();
            }

            Commander.Instance.RunCommand(m_updateSaveVersion, parameters, delegate(Error error, Dictionary<string, object> result)
            {
                int unixTimestamp = Globals.GetUnixTimestamp();

                if (result != null && result.ContainsKey("unixTimestamp"))
                {
                    try
                    {
                        unixTimestamp = Convert.ToInt32(result["unixTimestamp"]);
                    }
                    catch (Exception) { }
                }

                onUpdate(error, unixTimestamp);
            });
        }

        public void RecordPushToken(string token, Action<bool> onRecorded)
        {
            Dictionary<string, string> parameters = new Dictionary<string, string>
            {
                { "token", token },
            };

            Commander.Instance.RunCommand(m_recordTokenCommand, parameters, delegate(Error error, Dictionary<string, object> result)
            {
                bool recorded = false;

                if(error == null)
                {
                    if(result.ContainsKey("success") && (bool)result["success"])
                    {
                        Debug.Log("Authenticator :: (RecordToken) successful!");
                        recorded = true;
                    }
                    else
                    {
                        Debug.LogWarning("Authenticator :: (RecordToken) failed!");
                    }
                }
                else
                {
                    Debug.LogWarning("Authenticator :: (RecordToken) failed with error - " + error);
                }

                onRecorded(recorded);
            });
        }

        public void CheckGameVersion(Action<bool> onCheckComplete)
        {
            Commander.Instance.RunCommand(m_updateSaveVersion, new Dictionary<string, string>(), delegate(Error error, Dictionary<string, object> result)
            {
                bool upgradeAvailable = false;

                if(error == null && result.ContainsKey("upgradeAvailable") && (bool)result["upgradeAvailable"])
                {
                    upgradeAvailable = true;
                }

                onCheckComplete(upgradeAvailable);
            });
        }
    }
}
