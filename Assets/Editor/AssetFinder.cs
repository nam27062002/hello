// MonoBehaviourTemplateEditor.cs
// Hungry Dragon
// 
// Created by Alger Ortín Castellví on DD/MM/2016.
// Copyright (c) 2016 Ubisoft. All rights reserved.

//----------------------------------------------------------------------//
// INCLUDES																//
//----------------------------------------------------------------------//
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;

//----------------------------------------------------------------------//
// CLASSES																//
//----------------------------------------------------------------------//
/// <summary>
/// Custom editor window.
/// </summary>
public class AssetFinder : EditorWindow {
	//------------------------------------------------------------------//
	// CONSTANTS														//
	//------------------------------------------------------------------//

	//------------------------------------------------------------------//
	// MEMBERS AND PROPERTIES											//
	//------------------------------------------------------------------//
	// Window instance
	private static AssetFinder m_instance = null;
	public static AssetFinder instance {
		get {
			if(m_instance == null) {
				m_instance = (AssetFinder)EditorWindow.GetWindow(typeof(AssetFinder));
			}
			return m_instance;
		}
	}

    //------------------------------------------------------------------------//
    // Find any asset type in Content browser
    //------------------------------------------------------------------------//
    public static void FindAssetInContent<T>(string path, out T[] assetList) where T : UnityEngine.Object
    {
        List<T> objList = new List<T>();

        //        string[] fileList = Directory.GetFiles(path, "*", SearchOption.AllDirectories);
        string typeName = typeof(T).ToString();
        typeName = typeName.Contains("UnityEngine") ? typeName.Replace("UnityEngine.", "") : typeName;
        string filter = "t:" + typeName;
        Debug.Log("filter: " + filter);
        string[] guids = AssetDatabase.FindAssets(filter);

        foreach (string guid in guids)
        {
            string assetPath = AssetDatabase.GUIDToAssetPath(guid);

            T asset = AssetDatabase.LoadAssetAtPath<T>(assetPath);

            if (asset != null)
            {
                objList.Add(asset);
            }
        }

        assetList = objList.ToArray();
    }

    //------------------------------------------------------------------------//
    // Find any asset type in Content browser
    //------------------------------------------------------------------------//
    public static void FindAssetInScene<T>(out T[] assetList, bool _includeInactive = false) where T : UnityEngine.Object
    {
        //        assetList = Object.FindObjectsOfType(typeof(T)) as T[];
        if (_includeInactive)
        {
            assetList = GameObjectExt.FindObjectsOfType<T>(true).ToArray();
        }
        else
        {
            assetList = Object.FindObjectsOfType(typeof(T)) as T[];
        }
    }


    /// <summary>
    /// Remove unless collision data
    /// </summary>
    /// 
    [MenuItem("Hungry Dragon/Tools/Remove unless collision data")]
    public static void RemoveUnlessCollisionData()
    {
        Mesh[] meshList;
        FindAssetInScene<Mesh>(out meshList);
//        Undo.RecordObjects(meshList, "Regenerate scene colliders");

        for (int c = 0; c < meshList.Length; c++)
        {
            if (meshList[c].name == "PolyMesh_Autogenerated_Collider")
            {
                Undo.DestroyObjectImmediate(meshList[c]);
//                DestroyImmediate(meshList[c]);
            } else
            if (meshList[c].name == "PolyMesh_Autogenerated_Mesh")
            {
                Undo.DestroyObjectImmediate(meshList[c]);
                //                DestroyImmediate(meshList[c]);
            }
        }

        PolyMesh[] gameobjList;

        FindAssetInScene<PolyMesh>(out gameobjList, true);
//        Undo.RecordObjects(gameobjList, "Regenerate scene colliders");
        foreach (PolyMesh obj in gameobjList)
        {
            //            Undo.RecordObject(obj.gameObject, "record gameobject");
            //            obj.RebuildMesh(true);
            //            if (meshFilter != null)
            //            {
            //                Undo.DestroyObjectImmediate(meshFilter);
            //            }

            obj.RebuildMesh();
/*
            MeshFilter meshFilter = obj.gameObject.GetComponent<MeshFilter>();

            MeshCollider meshCollider = obj.gameObject.GetComponent<MeshCollider>();

            meshCollider.sharedMesh = null;
            meshCollider.sharedMesh = meshFilter.mesh;
*/
            //            if (meshRenderer != null)
            //            {
            //                Undo.DestroyObjectImmediate(meshRenderer);
            //            }

        }
    }


    /// <summary>
    /// Static Batching disable editor tool
    /// </summary>
    /// 
    [MenuItem("Hungry Dragon/Tools/Static Batching disable")]
    public static void SceneStaticBatchingDisable()
    {
        GameObject[] gameobjList;
        FindAssetInScene<GameObject>(out gameobjList);
        Undo.RecordObjects(gameobjList, "Disable static batching");
        foreach (GameObject obj in gameobjList)
        {
            StaticEditorFlags staticFlags = GameObjectUtility.GetStaticEditorFlags(obj);
            staticFlags &= ~(StaticEditorFlags.BatchingStatic | StaticEditorFlags.NavigationStatic | StaticEditorFlags.OffMeshLinkGeneration | StaticEditorFlags.ReflectionProbeStatic);
            GameObjectUtility.SetStaticEditorFlags(obj, staticFlags);
        }
    }


    /// <summary>
    /// Resets all shader keywords stored in materials or material selection
    /// </summary>
    [MenuItem("Hungry Dragon/Tools/Material keyword reset")]
    public static void MaterialkeywordReset()
    {
        Debug.Log("Obtaining material list");

//        EditorUtility.("Material keyword reset", "Obtaining Material list ...", "");

        Material[] materialList;
        FindAssetInContent<Material>(Directory.GetCurrentDirectory() + "\\Assets", out materialList);

//        AssetDatabase.StartAssetEditing();
        for (int c = 0; c <materialList.Length; c++)
        {
            materialList[c].shaderKeywords = null;
            EditorUtility.SetDirty(materialList[c]);
        }

        AssetDatabase.SaveAssets();

        Debug.Log("list length: " + materialList.Length);

    }

    /// <summary>
    /// Resets all shader keywords stored in materials or material selection
    /// </summary>
    [MenuItem("Hungry Dragon/Tools/Texture mipmap reset")]
    public static void TextureMipmapReset()
    {
        Debug.Log("Obtaining texture list");

        //        EditorUtility.("Material keyword reset", "Obtaining Material list ...", "");

        Texture2D[] textureList;
        FindAssetInContent<Texture2D>(Directory.GetCurrentDirectory() + "\\Assets", out textureList);

        float c = 0;
        foreach (Texture2D texture in textureList)
        {
            string path = AssetDatabase.GetAssetPath(texture);
            TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
            textureImporter.mipmapEnabled = false;
                       
            if (EditorUtility.DisplayCancelableProgressBar( "Reimporting texture", path, c / (float)textureList.Length))
            {
                EditorUtility.ClearProgressBar();
                break;
            }

            AssetDatabase.ImportAsset(path);
        }

        Debug.Log("list length: " + textureList.Length);

    }

    /// <summary>
    /// Resets all shader keywords stored in materials or material selection
    /// </summary>
    /// 
    public static int checkRepeatedName(ref Spawner[] spawnerList, string name)
    {
        int count = 0;
        foreach (Spawner obj in spawnerList)
        {
            if (obj.gameObject.name == name)
            {
                count++;
            }
        }

        return count;
    }

    public static int checkTriggerArray(Spawner.SpawnCondition[] triggerArray)
    {
        if (triggerArray.Length > 0)
        {
            for (int c = 0; c < triggerArray.Length; c++)
            {
                if (triggerArray[c].type == Spawner.SpawnCondition.Type.XP)
                {
                    return c;
                }
            }
        }
        return -1;
    }


    [MenuItem("Hungry Dragon/Tools/Spawners rename")]
    public static void SceneSpawnersRename()
    {
        Spawner[] spawnerList;
        FindAssetInScene<Spawner>(out spawnerList);
        Undo.RecordObjects(spawnerList, "Disable static batching");
        foreach (Spawner obj in spawnerList)
        {
            int activationCheck = checkTriggerArray(obj.activationTriggers);
            int deactivationCheck = checkTriggerArray(obj.deactivationTriggers);

            Spawner.SpawnCondition activation = (activationCheck >= 0) ? obj.activationTriggers[activationCheck] : null;
            Spawner.SpawnCondition deactivation = (deactivationCheck >= 0) ? obj.deactivationTriggers[deactivationCheck] : null;
            Object prefab = EditorUtility.GetPrefabParent(obj.gameObject);
            if (prefab != null)
            {
                string prefabName = prefab.name;
                if (activation != null || deactivation != null)
                {
                    prefabName = prefabName + "_" + ((activation != null) ? activation.value.ToString() : "0") + "_" + ((deactivation != null) ? deactivation.value.ToString() : "0");
                }
                obj.gameObject.name = prefabName;
            }
        }
    }



    //------------------------------------------------------------------//
    // METHODS															//
    //------------------------------------------------------------------//
    /// <summary>
    /// Opens the window.
    /// </summary>
    public static void OpenWindow() {
		instance.Show();
	}

	/// <summary>
	/// The editor has been enabled - target object selected.
	/// </summary>
	private void OnEnable() {
		
	}

	/// <summary>
	/// The editor has been disabled - target object unselected.
	/// </summary>
	private void OnDisable() {

	}


	/// <summary>
	/// Update the inspector window.
	/// </summary>
	public void OnGUI() {

	}

}