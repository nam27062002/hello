// MonoBehaviourTemplateEditor.cs
// Hungry Dragon
// 
// Created by Alger Ortín Castellví on DD/MM/2016.
// Copyright (c) 2016 Ubisoft. All rights reserved.

//----------------------------------------------------------------------//
// INCLUDES																//
//----------------------------------------------------------------------//
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;

//----------------------------------------------------------------------//
// CLASSES																//
//----------------------------------------------------------------------//
/// <summary>
/// Custom editor window.
/// </summary>
public class AssetFinder : EditorWindow {
	//------------------------------------------------------------------//
	// CONSTANTS														//
	//------------------------------------------------------------------//

	//------------------------------------------------------------------//
	// MEMBERS AND PROPERTIES											//
	//------------------------------------------------------------------//
	// Window instance
	private static AssetFinder m_instance = null;
	public static AssetFinder instance {
		get {
			if(m_instance == null) {
				m_instance = (AssetFinder)EditorWindow.GetWindow(typeof(AssetFinder));
			}
			return m_instance;
		}
	}

    //------------------------------------------------------------------------//
    // Find any asset type in Content browser
    //------------------------------------------------------------------------//
    public static void FindAssetInContent<T>(string path, out T[] assetList) where T : UnityEngine.Object
    {
        List<T> objList = new List<T>();

        //        string[] fileList = Directory.GetFiles(path, "*", SearchOption.AllDirectories);
        string typeName = typeof(T).ToString();
        typeName = typeName.Contains("UnityEngine") ? typeName.Replace("UnityEngine.", "") : typeName;
        string filter = "t:" + typeName;
        Debug.Log("filter: " + filter);
        string[] guids = AssetDatabase.FindAssets(filter);

        foreach (string guid in guids)
        {
            string assetPath = AssetDatabase.GUIDToAssetPath(guid);

            T asset = AssetDatabase.LoadAssetAtPath<T>(assetPath);

            if (asset != null)
            {
                objList.Add(asset);
            }
        }

        assetList = objList.ToArray();
    }

    //------------------------------------------------------------------------//
    // Find any asset type in Content browser
    //------------------------------------------------------------------------//
    public static void FindAssetInScene<T>(out T[] assetList, bool _includeInactive = false) where T : UnityEngine.Object
    {
        //        assetList = Object.FindObjectsOfType(typeof(T)) as T[];
        if (_includeInactive)
        {
            assetList = GameObjectExt.FindObjectsOfType<T>(true).ToArray();
        }
        else
        {
            assetList = Object.FindObjectsOfType(typeof(T)) as T[];
        }
    }


    /// <summary>
    /// Remove unless collision data
    /// </summary>
    /// 
    [MenuItem("Hungry Dragon/Tools/Remove unless collision data")]
    public static void RemoveUnlessCollisionData()
    {
        Mesh[] meshList;
        FindAssetInScene<Mesh>(out meshList);
//        Undo.RecordObjects(meshList, "Regenerate scene colliders");

        for (int c = 0; c < meshList.Length; c++)
        {
            if (meshList[c].name == "PolyMesh_Autogenerated_Collider")
            {
                Undo.DestroyObjectImmediate(meshList[c]);
//                DestroyImmediate(meshList[c]);
            } else
            if (meshList[c].name == "PolyMesh_Autogenerated_Mesh")
            {
                Undo.DestroyObjectImmediate(meshList[c]);
                //                DestroyImmediate(meshList[c]);
            }
        }

        PolyMesh[] gameobjList;

        FindAssetInScene<PolyMesh>(out gameobjList, true);
//        Undo.RecordObjects(gameobjList, "Regenerate scene colliders");
        foreach (PolyMesh obj in gameobjList)
        {
            //            Undo.RecordObject(obj.gameObject, "record gameobject");
            //            obj.RebuildMesh(true);
            //            if (meshFilter != null)
            //            {
            //                Undo.DestroyObjectImmediate(meshFilter);
            //            }

            obj.RebuildMesh();
/*
            MeshFilter meshFilter = obj.gameObject.GetComponent<MeshFilter>();

            MeshCollider meshCollider = obj.gameObject.GetComponent<MeshCollider>();

            meshCollider.sharedMesh = null;
            meshCollider.sharedMesh = meshFilter.mesh;
*/
            //            if (meshRenderer != null)
            //            {
            //                Undo.DestroyObjectImmediate(meshRenderer);
            //            }

        }
    }


    /// <summary>
    /// Static Batching disable editor tool
    /// </summary>
    /// 
    [MenuItem("Hungry Dragon/Tools/Static Batching disable")]
    public static void SceneStaticBatchingDisable()
    {
        GameObject[] gameobjList;
        FindAssetInScene<GameObject>(out gameobjList);
        Undo.RecordObjects(gameobjList, "Disable static batching");
        foreach (GameObject obj in gameobjList)
        {
            StaticEditorFlags staticFlags = GameObjectUtility.GetStaticEditorFlags(obj);
            staticFlags &= ~(StaticEditorFlags.BatchingStatic | StaticEditorFlags.NavigationStatic | StaticEditorFlags.OffMeshLinkGeneration | StaticEditorFlags.ReflectionProbeStatic);
            GameObjectUtility.SetStaticEditorFlags(obj, staticFlags);
        }
    }


    /// <summary>
    /// Select preloaded audioclips
    /// </summary>
    [MenuItem("Hungry Dragon/Tools/Select preloaded audioclips")]
    public static void SelectPreloadedAudioClips()
    {
        List<AudioClip> fList = new List<AudioClip>();
        AudioClip[] audioList;
        FindAssetInContent<AudioClip>(Directory.GetCurrentDirectory() + "\\Assets", out audioList);
        foreach(AudioClip clip in audioList)
        {
            if (clip.preloadAudioData)
            {
                fList.Add(clip);
            }
        }

        Selection.objects = fList.ToArray();
    }


    /// <summary>
    /// Resets all shader keywords stored in materials or material selection
    /// </summary>
    [MenuItem("Hungry Dragon/Tools/Material keyword reset")]
    public static void MaterialkeywordReset()
    {
        Debug.Log("Obtaining material list");

//        EditorUtility.("Material keyword reset", "Obtaining Material list ...", "");

        Material[] materialList;
        FindAssetInContent<Material>(Directory.GetCurrentDirectory() + "\\Assets", out materialList);

//        AssetDatabase.StartAssetEditing();
        for (int c = 0; c <materialList.Length; c++)
        {
            materialList[c].shaderKeywords = null;
            EditorUtility.SetDirty(materialList[c]);
        }

        AssetDatabase.SaveAssets();

        Debug.Log("list length: " + materialList.Length);

    }

    /// <summary>
    /// Resets all shader keywords stored in materials or material selection
    /// </summary>
    [MenuItem("Hungry Dragon/Tools/Texture mipmap reset")]
    public static void TextureMipmapReset()
    {
        Debug.Log("Obtaining texture list");

        //        EditorUtility.("Material keyword reset", "Obtaining Material list ...", "");

        Texture2D[] textureList;
        FindAssetInContent<Texture2D>(Directory.GetCurrentDirectory() + "\\Assets", out textureList);

        float c = 0;

        Debug.Log("Enabled mipmap textures :");
        foreach (Texture2D texture in textureList)
        {
            string path = AssetDatabase.GetAssetPath(texture);
            TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
                       
            if (EditorUtility.DisplayCancelableProgressBar( "Reimporting texture", path, c / (float)textureList.Length))
            {
                EditorUtility.ClearProgressBar();
                break;
            }
            if (textureImporter != null && textureImporter.mipmapEnabled)
            {
                textureImporter.mipmapEnabled = false;
                AssetDatabase.ImportAsset(path);
                Debug.Log(">>> " + path);
                c++;                   

            }
        }

        EditorUtility.ClearProgressBar();
        Debug.Log("list length: " + textureList.Length + " Mipmap textures:" + c);

    }

    /// <summary>
    /// Resets all shader keywords stored in materials or material selection
    /// </summary>
    [MenuItem("Hungry Dragon/Tools/Seek for directional lights")]
    public static void seekForLights()
    {

        Light[] lightList;
        FindAssetInScene<Light>(out lightList);

        for (int c = 0; c < lightList.Length; c++)
        {
            if (lightList[c].type == LightType.Directional)
            {
                Debug.Log("Directional Light: " + lightList[c].gameObject.name);
            }
        }

        Debug.Log("list length: " + lightList.Length);

    }



    /// <summary>
    /// Resets all shader keywords stored in materials or material selection
    /// </summary>
    /// 
    public static int checkRepeatedName(ref Spawner[] spawnerList, string name)
    {
        int count = 0;
        foreach (Spawner obj in spawnerList)
        {
            if (obj.gameObject.name == name)
            {
                count++;
            }
        }

        return count;
    }

    public static int checkTriggerArray(Spawner.SpawnCondition[] triggerArray)
    {
        if (triggerArray.Length > 0)
        {
            for (int c = 0; c < triggerArray.Length; c++)
            {
                if (triggerArray[c].type == Spawner.SpawnCondition.Type.XP)
                {
                    return c;
                }
            }
        }
        return -1;
    }


	public static int checkTriggerArrayTime(Spawner.SpawnCondition[] triggerArray)
	{
		if (triggerArray.Length > 0)
		{
			for (int c = 0; c < triggerArray.Length; c++)
			{
				if (triggerArray[c].type == Spawner.SpawnCondition.Type.TIME)
				{
					return c;
				}
			}
		}
		return -1;
	}
	/*
	public static int checkTriggerArrayKill(Spawner.SpawnKillCondition[] triggerArray)
	{
		if (triggerArray.Length > 0)
		{
			for (int c = 0; c < triggerArray.Length; c++) 
			{
				if (triggerArray [c].category.Length > 0)
					return c;
			}
		}
		return -1;
	}
*/

    [MenuItem("Hungry Dragon/Balancing/Spawners Rename Part 1")]
    public static void SceneSpawnersRenamePart1()
    {
        Spawner[] spawnerList;
        FindAssetInScene<Spawner>(out spawnerList,true);
        Undo.RecordObjects(spawnerList, "Disable static batching");
        foreach (Spawner obj in spawnerList)
        {
            int activationCheck = checkTriggerArray(obj.activationTriggers);
            int deactivationCheck = checkTriggerArray(obj.deactivationTriggers);
			int activationCheckTime = checkTriggerArrayTime(obj.activationTriggers);
			int deactivationCheckTime = checkTriggerArrayTime(obj.deactivationTriggers);
			//int activationCheckKill = checkTriggerArrayKill (obj.activationKillTriggers);
			//int deactivationCheckKill = checkTriggerArrayKill (obj.deactivationKillTriggers);

            Spawner.SpawnCondition activation = (activationCheck >= 0) ? obj.activationTriggers[activationCheck] : null;
            Spawner.SpawnCondition deactivation = (deactivationCheck >= 0) ? obj.deactivationTriggers[deactivationCheck] : null;
			Spawner.SpawnCondition activationTime = (activationCheckTime >= 0) ? obj.activationTriggers[activationCheckTime] : null;
			Spawner.SpawnCondition deactivationTime = (deactivationCheckTime >= 0) ? obj.deactivationTriggers[deactivationCheckTime] : null;
			//Spawner.SpawnKillCondition activationKill = (activationCheckKill >= 0) ? obj.activationTriggers[activationCheckKill] : null;
			//Spawner.SpawnKillCondition deactivationKill = (deactivationCheckKill >= 0) ? obj.activationTriggers[deactivationCheckKill] : null;

            Object prefab = EditorUtility.GetPrefabParent(obj.gameObject);
            if (prefab != null)
            {
                string prefabName = prefab.name;
                if (activation != null || deactivation != null)
                {
                    prefabName = prefabName + "_XP_" + ((activation != null) ? activation.value.ToString() : "0") + "_" + ((deactivation != null) ? deactivation.value.ToString() : "0");
                }
				if (activationTime != null || deactivationTime != null)
				{
					prefabName = prefabName + "_TIME_" + ((activationTime != null) ? activationTime.value.ToString() : "0") + "_" + ((deactivationTime != null) ? deactivationTime.value.ToString() : "0");
				}
				/*if (activationKill != null || deactivationKill != null) 
				{
					prefabName = prefabName + "_KILL_";
				}*/
				obj.gameObject.name = prefabName + "@";
				// Inactive spawners ends with "-IN"
				if (!obj.gameObject.activeInHierarchy)
					obj.gameObject.name = prefabName + "-IN"; 
            }
        }
    }

	[MenuItem("Hungry Dragon/Balancing/Spawners Rename Part 2")]
	public static void SceneSpawnersRenamePart2()
	{
		Spawner[] spawnerList;
		FindAssetInScene<Spawner>(out spawnerList,true);
		Undo.RecordObjects(spawnerList, "Disable static batching");
		foreach (Spawner obj in spawnerList)
		{
			int activationCheck = checkTriggerArray(obj.activationTriggers);
			int deactivationCheck = checkTriggerArray(obj.deactivationTriggers);
			int activationCheckTime = checkTriggerArrayTime(obj.activationTriggers);
			int deactivationCheckTime = checkTriggerArrayTime(obj.deactivationTriggers);

			Spawner.SpawnCondition activation = (activationCheck >= 0) ? obj.activationTriggers[activationCheck] : null;
			Spawner.SpawnCondition deactivation = (deactivationCheck >= 0) ? obj.deactivationTriggers[deactivationCheck] : null;
			Spawner.SpawnCondition activationTime = (activationCheckTime >= 0) ? obj.activationTriggers[activationCheckTime] : null;
			Spawner.SpawnCondition deactivationTime = (deactivationCheckTime >= 0) ? obj.deactivationTriggers[deactivationCheckTime] : null;
			Object prefab = EditorUtility.GetPrefabParent(obj.gameObject);
			if (prefab != null)
			{
				string prefabName = prefab.name;
				if (activation != null || deactivation != null)
				{
					prefabName = prefabName + "_XP_" + ((activation != null) ? activation.value.ToString() : "0") + "_" + ((deactivation != null) ? deactivation.value.ToString() : "0");
				}
				if (activationTime != null || deactivationTime != null)
				{
					prefabName = prefabName + "_TIME_" + ((activationTime != null) ? activationTime.value.ToString() : "0") + "_" + ((deactivationTime != null) ? deactivationTime.value.ToString() : "0");
				}					
				obj.gameObject.name = prefabName.Replace("@","");
				// Inactive spawners ends with "-IN"
				if (!obj.gameObject.activeInHierarchy)
					obj.gameObject.name = prefabName + "-IN";
			}
		}
	}



    //------------------------------------------------------------------//
    // METHODS															//
    //------------------------------------------------------------------//
    /// <summary>
    /// Opens the window.
    /// </summary>
    public static void OpenWindow() {
		instance.Show();
	}

	/// <summary>
	/// The editor has been enabled - target object selected.
	/// </summary>
	private void OnEnable() {
		
	}

	/// <summary>
	/// The editor has been disabled - target object unselected.
	/// </summary>
	private void OnDisable() {

	}


	/// <summary>
	/// Update the inspector window.
	/// </summary>
	public void OnGUI() {

	}

}